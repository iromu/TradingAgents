<html
        xmlns:th="http://www.thymeleaf.org"
        th:replace="~{common/layout :: layout(~{::title}, ~{::section}, ~{::extraHeadContent})}">
<head>
    <th:block th:fragment="extraHeadContent">
        <script src="https://unpkg.com/marked@12.0.2/marked.min.js"></script>
        <script src="https://unpkg.com/dompurify@3.1.7/dist/purify.min.js"></script>
    </th:block>
    <title>Processing</title>

</head>
<body>
<section>
    <h2 th:text="${pageTitle}"></h2>
    <div id="agent-container">
        <div id="agent-status">
            <div class="working">
                <p th:text="${detail}"></p>

                <div class="process-controls">
                    <button type="button"
                            th:hx-delete="@{/api/v1/process/{id}(id=${processId})}"
                            hx-confirm="Are you sure you want to kill this process?"
                            hx-target="this"
                            hx-swap="outerHTML"
                            class="scary-delete-btn">
                        Kill Process
                    </button>
                </div>
                <div class="spinner"></div>
            </div>
        </div>
        <div id="current-plan">
            <h3>Plan</h3>
            <div id="plan-content"></div>
        </div>
        <div id="sse-updates">
            <p id="init-message">Initializing...</p>
        </div>
    </div>

    <!-- Template for process updates -->
    <template id="update-template">
        <div class="process-update">
            <div class="update-header" data-field="header"></div>
            <div class="update-details" data-field="details"></div>
            <div class="update-details" data-field="event-type"></div>
            <pre class="json-content hidden" data-field="json"></pre>
            <div class="md-content hidden" data-field="md"></div>
        </div>
    </template>

    <script>
        const processId = '[[${processId}]]';
        const eventSource = new EventSource(`/events/process/${processId}`);
        const updatesContainer = document.getElementById('sse-updates');
        const initMessage = document.getElementById('init-message');
        const updateTemplate = document.getElementById('update-template');
        const currentPlanElement = document.getElementById('current-plan');
        const planContentElement = document.getElementById('plan-content');

        // Store tool call elements by their ID for later updates
        const toolCallElements = new Map();

        function isMarkdown(text) {
            if (typeof text !== "string") return false;

            return /(^#{1,6}\s)|(\*\*)|(```)|(\[.+\]\(.+\))|(^\s*[-*+]\s)/m.test(text);
        }

        function renderMarkdown(md) {
            if (!window.marked) {
                return md; // fallback: return raw text
            }

            const rawHtml = marked.parse(md);
            return window.DOMPurify
                ? DOMPurify.sanitize(rawHtml)
                : rawHtml;
        }

        function normalizeResult(result) {
            if (result == null) {
                return {type: null, value: null};
            }

            // JSON object
            if (typeof result === "object") {
                return {
                    type: "json",
                    value: JSON.stringify(result, null, 2)
                };
            }

            // String
            if (typeof result === "string") {

                // Try JSON
                try {
                    const json = JSON.parse(result);
                    return {
                        type: "json",
                        value: JSON.stringify(json, null, 2)
                    };
                } catch {
                    // not JSON
                }

                // Markdown
                if (isMarkdown(result)) {
                    return {
                        type: "markdown",
                        value: renderMarkdown(result)
                    };
                }
            }

            return {type: null, value: null};
        }

        function createUpdateElement(data) {
            // Clone the template
            const clone = updateTemplate.content.cloneNode(true);
            const updateDiv = clone.querySelector('.process-update');

            // Get all the field elements
            const headerEl = updateDiv.querySelector('[data-field="header"]');
            const detailsEl = updateDiv.querySelector('[data-field="details"]');
            const eventTypeEl = updateDiv.querySelector('[data-field="event-type"]');
            const jsonEl = updateDiv.querySelector('[data-field="json"]');
            const mdEl = updateDiv.querySelector('[data-field="md"]');

            // Set content based on event type
            let headerText = "";
            let detailsText = "";
            let showJson = false;
            let showMarkdown = false;
            let normalized = "";

            switch (data.type) {
                case 'AgentProcessPlanFormulatedEvent':
                    //headerText = `üìã Plan Formulated`;
                    if (data.plan?.actions) {
                        const history = data.history.map(ai => ai.actionName)
                        const planned = data.plan.actions.map(action => action.description);
                        const actionsList = history.concat(planned).map((action, index) => {
                            let icon;
                            if (history.includes(action)) {
                                icon = "‚úÖ"; // Completed actions
                            } else if (index === history.length) {
                                icon = "‚öôÔ∏è"; // First planned action (currently working)
                            } else {
                                icon = "‚òê"; // Other planned actions
                            }

                            return `<li class="plan-action-item">
                                        <div class="action-icon">${icon}</div>
                                        <div class="action-name">${action}</div>
                                     </li>`;
                        }).join('');

                        // Update sticky plan area with styled HTML elements
                        planContentElement.innerHTML = `
                        <span class="plan-action-item">üéØ&nbsp;&nbsp;Goal: ${data.plan?.goal?.description} (${data.plan?.goal?.name})</span>
                            <ul class="plan-actions-list">
                                ${actionsList}
                            </ul>
                        `;
                        // Make the current plan visible
                        currentPlanElement.classList.add('visible');
                    } else {
                        detailsText = 'Plan details not available';
                    }
                    return null; // Don't add a box for plan formulation
                    break;

                case 'ActionExecutionStartEvent':
                    headerText = `üöÄ Executing Action ${data.action?.description?.replace('_', ' ') || 'Unknown action'}`;
                    detailsText = data.action?.description?.replace('_', ' ') || 'Unknown action';
                    break;
                case 'ObjectAddedEvent':
                    headerText = `‚ûï Object Added`;
                    detailsText = `Object of type ${data.type}`;
                    break;
                case 'ObjectBoundEvent':
                    headerText = `‚ûï Object Bound`;
                    detailsText = `${data.name} = object of type ${data.type}`;
                    break;
                case 'ToolCallRequestEvent':
                    headerText = `üîß Tool Call ${data.tool}`;
                    detailsText = `${data.tool} ${data.toolInput}`;
                    // Store the element reference with the tool call ID
                    if (data.id) {
                        updateDiv.setAttribute('data-tool-call-id', data.correlationId);
                        toolCallElements.set(data.id, updateDiv);
                    }
                    break;
                case 'ToolCallResponseEvent':
                    // Instead of creating a new element, find the corresponding request element
                    if (data.request?.correlationId && toolCallElements.has(data.request?.correlationId)) {
                        return null; // Return null to indicate no new element should be created
                    }
                    headerText = `üîß Tool Response ${data.tool}`;
                    detailsText = `${data.tool} ${data.toolInput}`;
                    //detailsText = 'Tool response received';
                    normalized = normalizeResult(data.result);

                    if (normalized?.type === "json") {
                        showJson = true;
                        jsonEl.textContent = normalized.value;
                    }

                    if (normalized?.type === "markdown") {
                        showMarkdown = true;
                        mdEl.innerHTML = normalized.value;
                    }
                    break;
                case 'LlmRequestEvent':
                    headerText = `ü§ñ LLM Request - ${data.interaction?.id} - ${data.llm?.name}`;
                    normalized = normalizeResult(data.prompt);

                    if (normalized?.type === "json") {
                        showJson = true;
                        jsonEl.textContent = normalized.value;
                    }

                    if (normalized?.type === "markdown") {
                        showMarkdown = true;
                        mdEl.innerHTML = normalized.value;
                    }
                    break;
                case 'ChatModelCallEvent':
                    headerText = `ü§ñ Chat Call - ${data.llm?.name}`;
                    normalized = normalizeResult(data.springAiPrompt?.contents);

                    if (normalized?.type === "json") {
                        showJson = true;
                        jsonEl.textContent = normalized.value;
                    }

                    if (normalized?.type === "markdown") {
                        showMarkdown = true;
                        mdEl.innerHTML = normalized.value;
                    }
                    break;
                case 'LlmResponseEvent':
                    headerText = `üí¨ LLM Response - ${data.request?.interaction?.id}- ${data.request?.llm?.name}`;
                    normalized = normalizeResult(data.result);

                    if (normalized?.type === "json") {
                        showJson = true;
                        jsonEl.textContent = normalized.value;
                    }

                    if (normalized?.type === "markdown") {
                        showMarkdown = true;
                        mdEl.innerHTML = normalized.value;
                    }
                    break;
                default:
                    headerText = `‚ö° ${data.type.replace('Event', '')}`;
                    detailsText = 'Processing...'
                    // Don't add a box for unrecognized events
                    //return null;
                    break;
            }

            // Update element content
            headerEl.textContent = headerText;
            detailsEl.textContent = detailsText;
            // eventTypeEl.textContent = `Event: ${data.type}`;

            // Show/hide JSON based on event type
            if (showJson) {
                jsonEl.classList.remove('hidden');
            }
            if (showMarkdown) {
                mdEl.classList.remove('hidden');
            }

            return updateDiv;
        }

        function updateToolCallElement(data) {
            if (!data.request?.correlationId || !toolCallElements.has(data.request.correlationId)) {
                return false;
            }

            const toolCallElement = toolCallElements.get(data.request.correlationId);
            const detailsEl = toolCallElement.querySelector('[data-field="details"]');
            const jsonEl = toolCallElement.querySelector('[data-field="json"]');

            // Update the header to indicate it's now a response
            const headerEl = toolCallElement.querySelector('[data-field="header"]');
            headerEl.textContent = 'üîß Tool Call (Completed)';

            // Append response to details
            const originalDetails = detailsEl.textContent;
            detailsEl.textContent = `${originalDetails}\nResponse received`;

            // Show the JSON response
            jsonEl.textContent = normalizeJsonResult(data.response);
            jsonEl.classList.remove('hidden');

            return true;
        }

        eventSource.addEventListener('agent-process-event', function (event) {
            const data = JSON.parse(event.data);

            // Handle completion events
            if (data.type === "GoalAchievedEvent") {
                eventSource.close();

                // Get values from template context
                window.location.href = `/status/${processId}?resultModelKey=[[${resultModelKey}]]&successView=[[${successView}]]`;
                return;
            }

            // Remove initialization message on first real update
            if (initMessage && !initMessage.classList.contains('hidden')) {
                initMessage.classList.add('hidden');
            }

            // Handle tool call responses by updating existing elements
            if (data.type === 'ToolCallResponseEvent') {
                const updated = updateToolCallElement(data);
                if (updated) {
                    // No need to create a new element
                    return;
                }
            }

            // Create and append new update element
            const updateElement = createUpdateElement(data);
            if (updateElement) {  // Only append if an element was created
                updatesContainer.appendChild(updateElement);
                // Auto-scroll to latest update
                updateElement.scrollIntoView({behavior: 'smooth'});
            }
        });

        eventSource.addEventListener('error', function (event) {
            console.error('EventSource error:', event);
            const errorUpdate = createUpdateElement({
                type: 'ConnectionError',
                message: 'Connection to server lost'
            });
            updatesContainer.appendChild(errorUpdate);
        });
    </script>
</section>
</body>
</html>
